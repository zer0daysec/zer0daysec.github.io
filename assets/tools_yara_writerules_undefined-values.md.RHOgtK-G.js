import{_ as a,c as s,a3 as n,o as p}from"./chunks/framework.DtMx7FFi.js";const f=JSON.parse('{"title":"未定义的值","description":"","frontmatter":{"layout":"doc","title":"未定义的值"},"headers":[],"relativePath":"tools/yara/writerules/undefined-values.md","filePath":"tools/yara/writerules/undefined-values.md"}'),t={name:"tools/yara/writerules/undefined-values.md"};function o(i,e,d,l,c,r){return p(),s("div",null,e[0]||(e[0]=[n(`<div class="title-wrapper"><div class="page-title">未定义的值</div><div class="post-title">—— yara 使用手册 · 编写 yara 规则 <span class="lastModifyTime"><i class="fa-regular fa-clock"></i> 最后更新： 2023-03-14 21:12:12 </span></div></div><p>模块通常会将变量保留为未定义状态，例如当变量在当前上下文中没有意义时 (在扫描非 PE 文件时考虑 <code>pe.entry_point</code> )。Yara 以允许规则保持其意义的方式来处理未定义的值，看看这个规则：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import &quot;pe&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>rule Test</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    strings:</span></span>
<span class="line"><span>        $a = &quot;some string&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    condition:</span></span>
<span class="line"><span>        $a and pe.entry_point == 0x1000</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>如果扫描的文件不是 PE，即使文件包含字符串，此规则也不会与该文件匹配，因为必须满足两个条件 (字符串的存在和入口点的正确值)，然而，如果条件改为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$a or pe.entry_point == 0x1000</span></span></code></pre></div><p>在这种情况下，如果文件包含该字符串，即使它不是 PE 文件，你也会期望规则匹配。这正是 Yara 的行为方式。逻辑如下：</p><ul><li>如果条件中的表达式未定义，它将被转换为 false 并且规则将不匹配。</li><li>布尔运算符 <code>and</code> 和 <code>or</code> 会将未定义的操作数视为 false ，这意味着：<code>undefined and true</code> 是 false，<code>undefined and false</code> 是 false，<code>undefined or true</code> 是 true，<code>undefined or false</code> 是 false</li><li>其余所有运算符 (包括 <code>not</code> 运算符) 如果其中任何操作数未定义，则返回 undefined。</li></ul><p>在上面的表达式中，对于非 PE 文件，<code>pe.entry_point == 0x1000</code> 将未定义，因为 <code>pe.entry_point</code> 对于这些文件未定义，这意味着当且仅当 <code>$a</code> 是 <code>true</code> 时 <code>$a or pe.entry_point == 0x1000</code> 才会是 <code>true</code> 。</p><p>如果条件单独为 <code>pe.entry_point == 0x1000</code>，则对于非 PE 文件，它将判定为 false，<code>pe.entry_point != 0x1000</code> 和 <code>not pe.entry_point == 0x1000</code> 也会如此，因为这些表达式对于非 PE 文件都没有意义。</p><p>要检查表达式是否已定义，请使用一元运算符 defined，例子：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>defined pe.entry_point</span></span></code></pre></div>`,11)]))}const v=a(t,[["render",o]]);export{f as __pageData,v as default};
